/* 
    关于静态局部变量
    在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。

 */

#include<iostream>


/* 函数声明 */
void fn();

int main(int argc, char const *argv[])
{
    /* code */
    fn();
    fn();
    fn();
    return 0;
}

/* 函数定义 */
void fn()
{
    static int n = 10;
    std::cout<<n<<std::endl;
    n++;
}

/* 
10
11
12

 */


/* 
 通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。

通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。

静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。

静态局部变量有以下特点：

    该变量在全局数据区分配内存；
    静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
    静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
    它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；


 */