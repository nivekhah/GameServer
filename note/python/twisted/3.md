```
    Twisted的reactor只有通过调用reactor.run()才启动。
    reactor循环是在其开始的线程中运行，也就是运行在主线程中。
    一旦启动，reactor就会在程序的控制下（或者具体在一个启动它的线程的控制下）一直运行下去。
    reactor空转时并不会消耗任何CPU的资源。
    并不需要显式的创建reactor，只需要引入就OK了。

```



在Twisted中，reactor是Singleton模式，即在一个程序中只能有一个reactor，并且只要你引入它就相应地创建一个。上面引入的方式是twisted默认使用的方法，当然了，twisted还有其它可以引入reactor的方法。例如，可以使用twisted.internet.pollreactor来调用poll代替select方法。


```

    reactor模式是单线程的。
    像Twisted这种交互式模型已经实现了reactor循环，意味无需我们亲自去实现它。
    我们仍然需要框架来调用我们自己的代码来完成业务逻辑。
    因为在单线程中运行，要想跑我们自己的代码，必须在reactor循环中调用它们。
    reactor事先并不知道调用我们代码的哪个函数


```


```


    我们的代码与Twisted代码运行在同一个线程中。
    当我们的代码运行时，Twisted代码是处于暂停状态的。
    同样，当Twisted代码处于运行状态时，我们的代码处于暂停状态。
    reactor事件循环会在我们的回调函数返回后恢复运行。




```

```
我们应该确保回调函数不要浪费时间（尽快返回）。特别需要强调的是，我们应该尽量避免在回调函数中使用会阻塞I/O的函数。否则，我们将失去所有使用reactor所带来的优势。Twisted是不会采取特殊的预防措施来防止我们使用可阻塞的代码的，这需要我们自己来确保上面的情况不会发生。



```

### 如果有回调函数发生错误的话 会怎么办？

注意，尽管我们看到了因第一个回调函数引发异常而出现的跟踪栈，第二个回调函数依然能够执行。如果你将reactor.stop()注释掉的话，程序会继续运行下去。所以说，reactor并不会因为回调函数中出现失败（虽然它会报告异常）而停止运行。

网络服务器通常需要这种健壮的软件。它们通常不希望由于一个随机的Bug导致崩溃。也并不是说当我们发现自己的程序内部有问题时，就垂头丧气。只是想说Twisted能够很好的从失败的回调中返回并继续执行。
